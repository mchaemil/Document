





## 라이프 사이클

created 에서 돔에서 접근하면 안 된다. 

화면이 만들어지지 않았는데, 뿌리려고 하면..! 문제가 생긴다..!

화면에 대한 접근이 되지 않기 때문에..! 

### created, mounted가 중요한 두 개!!

화면이 생성되었을 때, 

beforeUpdate 실제 업데이트가 변경되었을 때

### 라이프 싸이클은 



데이터를 해제해서 누수를 막기 위해서 쓰인다...



### components

  템플릿은 데이터를 표현하고 싶은게 아니라 

  태그를 만들고 싶은 것이다. 



### Vue 

의존성이 생긴다. 

의존성(커플링? 커풀링..?)은 같은 말이다..! 

커플링이 있으면 재사용이 안된다. 

어떻게든 데이터를 가져올 수 있는 방법은 있지만 

데이터를 가져오면 안된다. 

의존성이 낮아야 좋다.

재사용성을 높일 수 있다. 

재사용성과 



## 백엔드와 프론트엔드의 책임 분리

사람들이 앱을 깔지 않는다..

웹 페이지를 또 만들어야 하는 버거움..!

충돌이 난다.

백엔드를 두고..!

화면을 아예 분리를 하는 방향으로 간다.

서버는 데이터만 내주고 화면은 내지 않는다.

프론트 서버가 백엔드와 통신을 한다. 



요즘은 서버가 쭉 데이터만 내려준다.

나는 데이터만 내려줄테니까 너희가 알아서 뿌려..!  이런 식으로 패러다임이 바뀌었다.

통신량은 많아지지만 개발량은 준다..!

실제 데이터는 변하는 게 없는데, 디자인이 변하는 경우가 많다.

이렇게 디자인만 바뀔 경우..! 백엔드가 필요없다..!

장고는 api 서버로 확 가버리고

뷰 같은 서버를 띄어서 화면을 그리는 역할을 한다.

스프링이 백엔드 서버를 제일 많이 쓰고 점유율도 높다.

뷰가 화면 그리는 모든 걸 가져간다

Vue코드의 상용 CDN은 코드의 최적화를 위해 띄어쓰기와 개행이 없다. 에러로 뱉지 않는다. 릴리즈 모드로 가면 브라우저 확장툴도 사용할 수 없다.



### 객체 지향 5대 원칙

1. 단일 책임원칙, 책임이란 기능 정도로 해석하면 된다.
2. 





리액트는 뷰를 개발하는 쪽에서 라이브러리로 뺴놨다!

뷰에는 라우팅 기능까지 들어와 있다.



## 뷰 라우터



유저 컴포넌트 위에 아무것도 없으면

파라미터가 아무것도 바라보지 않는다.



### 네임드 뷰

이름을 주는 컴포넌트에서 이름을 찾는다.



axios 는 자바스크립트 라이브러리 

초기에는 Vue 리소스를 썼었지만 2016년 말에 에반이 공식적으로 지원 종료..!

데이터 통신은 보통 비동기 처리를 한다.

너가 처리를 다했으면 이 함수를 실행시켜줘..!

언제 올지 모르므로..! 데이터가 안 올경우..! 



## HTTP 통신

```html
<!-- 1.3.4 버전만 가능함 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue-resource/1.3.4/vue-resource.js"></script>

<div id="app">
  <button v-on:click="getData">button</button>
</div>
```

```javascript
var app = new Vue({
  el:'#app',
  methods: {
    getData() {
      this.$http.get("https://raw.githubusercontent.com/joshua1988/doit-vuejs/master/data/demo.json")
      .then(res => {
        console.log(res)
        console.log(JSON.parse(res.data))
        // 통신이 되는 건 똑같지만 1.5버전이 넘어가면..! object로 날라온다..!
        // 버전을 낮추고 parse 하는 게 좋다.
      })
    }
  }
})
```





### Axios

갑자기 에러가 발생했을 때 catch가 발생한다.





## 뷰

### v-once

데이터가 10번 변하면..! 그때 한 번 바꾸겠다..!

화면을 그리는 비용은 비싸므로 데이터가 바뀔 때마다 바꾸면 연산비용이 많이 들 수 있다. 그래서 10번 바뀔 때 바꾸거나 다양한 방법을 사용한다. 그런 문제가.. 터질 수 있으므로..! 우리가 필요한 시점에 업데이트를 친다.!

쓰는 방법은 그때그때 다르지만..! 

특정 화면에서 업데이트가 너무 잦으니 업데이트 시점의 주체를 가져와서 해결한 적이 있다.



## 포트폴리오

자기소개할 때 이것저것 물어볼 수 있도록 유도할 수 있어야 한다.







### 표현식

표현식을 통해 연산이 가능하다.

화면단에는 로직을 처리하지 말고, computed를 사용하자

### 제이쿼리가 어렵다고 생각한다면..! 

어려운 게 있으니까 쉽게 만들려고 나온 것이다.

제이쿼리는 강력했지만..!  오히려 돔을 찾아 들어가는 과정이 어렵고 

성능을 개선하기 어렵다..! 



|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |

해외에는 최소한의 데이터만 왔다갔다하려고 네이티브 앱으로 많이 가는 추세이다.

for 문을 쓸 때는 ` v-bind:key`속성을 꼭 사용해야 한다. 그렇지 않으면 뷰를 사용하는 목적과 이유가 사라진다.  키가 없다고 에러나지 않지만..! 키를 넣어줘야 효율이 올라간다.!

쓰긴 쓰 데 왠만하면 유니크하게 써라. 변경된 부분만 빠르게 찾으려면 키가 있는 부분만 찾으면 된다.

이 리스트에서 뭐가 바뀌는 줄 모른다. 

```

```







### v-

if는 로그인처리 할 때 사용하게 된다.

for는 게시물 만들 때 주로 사용한다. 포문에는 키값이 들어간다.

`v-show` 와  `v-if` 의 차이는 메모리에 올라갈 떄 차이가 생긴다.! 미리 화면을 그려놓으면 연산비용을 아낄 수 있다..! 큰 프로그램을 만들 때는 선택해서 써야 하는 상황이 생길 수 있다. 

`v-on`  :@로 바꿔서 사용할 수 있다.

브이모델은 변경되었을 때, 속성을 연동만 해놓으면...! 바로바로 연동이 된다.리액트에서 처리를 할 때는 더 복잡했음..! 



## 고급 템플릿 문법 

### 백엔드보다 프론트가 더 민감하다

1초나 2초 보다 화면이 늦게 뜨면..! 닫는다.

굉장히 속도에 민감한...! 화면이 있다면..! 자바스크립트 표현식의 사용을 자제해야 한다.

가급적이면 모든 표현식은 컴퓨티드 속성 안에 넣는 게 좋다. 





### 캐싱

데이터에 접근하는 시간이 오래 걸릴 때 미리 저장해둠

캐싱을 무한대로 걸면 데이터가 바로바로 반영이 안되므로 텀을 주는 경우가 있다. 

캐싱은 많이 쓰게 된다. 

씨피유 내부에 캐시 메모리가 있다. 씨피유나 메모리 구조 쪽을 보면..!  

메모리가 비싼 연산을 위해서는 캐싱을 이용하는 게 좋다. 



캐싱을 위해선 캐싱 전략을 다 세워야 한다.

데이터가 변경되기 전까지는 한 번 연산을 한다. 뷰를 쓰게 되면 프레임워크가 최적화된 전략을 써준다..! 기본적인 성능은 보장을 해주려고 한다. 



> 만들고 싶은 기능이 있다면 구현 전에 찾아보는 것도..! 이미 만들어져 있을 수도..!

### 비동기

실제 네트워크..!네트워크르 가지고 온 다음에 데이터가 변경 안 되는 상황이 생길 때 왓치에 태워서 바로 바꾸어 버릴 수가 있다. 

### 원웨이와 투웨이의 차이

리액트는 상태가 바뀌면 변경되는 방식



리액트는 데이터를 가지고 와서 서버로 쳐야 한다..!!

뷰는 데이터가 변경되면 갱신하는 방식 이므로 서버로 데이터를 보낼 때도 리액트와 같은 작업을 하더라도 코드의 양이 줄어든다. 

### 웹 팩

app.js.. 하나가 나온다.

웹팩을 통해서 min.js로 만들어 준다. 

웹 팩으로 리액트.. 뷰 다쓰는 사람들은 사용해야 한다. 간단히 볼텐데..! 

웹 팩을 잘 쓰게 되면 할 수 있는 게 너무나 많다.

웹 팩을 한땀한땀 구축하는 건 어렵...



### 프록시

특정 에이피아이를 통해서 서버들의 경로들을 분할할 수 있는 정말 많은 기능들이 있다. 

### PWA





### TDD 

TDD 가 지금은 확 죽어버렸다...!

테스팅에 어떤 문제가 있다고 얘기했는데 반박을 못함

테스트를하게 되면 다 에러가 남..! 개발자가 리팩토링을 맘놓고, 믿을 수 있었다.

테스팅을 자동화할 수 있었다. 

테스팅 화면이 잘못되면 있으나 마나 아니냐...! 테스팅 자체가 문제가 되면 ..! 쓸모가 없다...



### 포트는 여러개 띄울 수 있는 방법은 알아두는 것이 좋다. 

```javascript
devServer: {
  historyApiFallback: true,
  port: 8081, // port번호를 설정할 수 있다.
  noInfo: true,
  overlay: true
},
```







### run build 를 꼭 해줘야 한다.



## 웹 팩

웹 팩은 웹 앱의 자원들을 자바스크립트 모듈로 변환해 하나로 묶어 웹 성능을 향상시켜주는 자바스크립트 모듈 번들러입니다.

### 웹 팩은 자바스크립트 파일만 인식한다

뷰 로더가 없으면 인식을 못한다. 뷰로더가 그 역할을 한다.

뷰로더는 웹팩이랑 자바스크립트 사이에 위치한다. 중간의 매개 역할을 한다.





## 프론트는 UI 요구사항이 많고, 백엔드는 데이터 정리 등의 요구사항이 많다.

### ---

예전에는 폴더와 파일을 잘 나눠놓아야 하는 시대가 있었지만..! 지금은 에디터들이 좋아서! 기본적으로 검색으로 찾는 개발자들도 있다.

### 그림자 속성은 연산이 비싸다. 투명도 연산은 비용이 비싸다...!

로직상 문제가 없으면 디자인쪽 문제가 있을 것이다..! 그림자랑 투명도 연산에 대해서는 주의해야 한다. 개발자들은 그림자 연산을 싫어함..





### ## debugger

## 

### ## debugger



## LocalStorage 

LocalStorage 는 로콜호스트 포트번호마다 저장하고 있는 정보가 다르다.



### 앞 뒤 공백 제거...!



인풋박스의 입력값은 초기화 하는 것도 중요하다.



### 네트워크를 타는 건 created를 사용한다.



### key 속성, 브라우저가 로딩되는 과정을 위해서 중요하다

개수 만개까지 뿌려주는 라이브러리가 있었다. 얼마나 웹 브라우저의 성능이 안 좋았으면... 요즘은 뷰를 쓰면 한 방에 끝나버린다. 





### 뷰가 쉽다는 이유는 데이터만 가지고 놀면 된다.

뷰가 쉽다는 이유는 데이터만 가지고 놀면 된다.리액트는 데이터를 변경하고 상태를 호출해야 하지만 뷰는 다르다..!





### 투 웨이와 원웨이 방식의 차이

v-model의 데이터 바인딩을 통해서 양방향 데이터 바인딩이 이루어지고

데이터 바인딩은 양방향 데이터 바인딩을 한다.

컴포넌트 간에 통신은 양방향으로 한다. 





## 웹 팩 test

```bash
vue init webpack


```

config 폴더가 생김





### 프로젝트


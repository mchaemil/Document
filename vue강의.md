## git fork test2



## 라이프 사이클

created 에서 돔에서 접근하면 안 된다. 

화면이 만들어지지 않았는데, 뿌리려고 하면..! 문제가 생긴다..!

화면에 대한 접근이 되지 않기 때문에..! 

### created, mounted가 라이프사이클에서 가장 중요한 두 개이다.

화면이 생성되었을 때, 

beforeUpdate 실제 업데이트가 변경되었을 때

### 라이프 싸이클은 

데이터를 해제해서 누수를 막기 위해서 쓰인다...



### components

components의 템플릿 속성은 데이터를 표현하고 싶은게 아니라 태그를 만들고 싶은 것이다. 



### Vue 

의존성이 생긴다. 

의존성(커플링? 커풀링..?)은 같은 말이다..! 

커플링이 있으면 재사용이 안된다. 

어떻게든 데이터를 가져올 수 있는 방법은 있지만 가급적이면 데이터를 가져오면 안된다. ~~집에 가야할 때를 빼고는~~



의존성이 낮아야 재사용성을 높일 수 있다. 



## 백엔드와 프론트엔드의 책임 분리

사람들이 앱을 깔지 않는다..

웹 페이지를 또 만들어야 하는 버거움..!

충돌이 난다.

백엔드를 두고..!

화면을 아예 분리를 하는 방향으로 간다.

서버는 데이터만 내주고 화면은 내지 않는다.

프론트 서버가 백엔드와 통신을 한다. 



요즘은 서버가 데이터만 내려주고, 화면에 대한 책임은 프론트에게 맡기는 식으로 패러다임이 바뀌었다. 이 때문에 통신량은 많아졌지만 개발량은 오히려 줄어들었다. 

예전에는 실제 데이터는 변하는 게 없더라도 디자인만 변하는 경우로 인해 개발을 하는 경우가 종종 있었다. 지금은 이렇게 디자인만 바뀔 경우 화면을 그리는 개발에는 백엔드가 필요 없다. 

가령, 장고는 api서버로만 기능하고, 뷰 같은 서버를 띄워서 화면을 그리는 모든 책임과 역할을 맡긴다. 

첨언하면, 스프링이 백엔드 서버를 제일 많이 쓰고, 점유율도 높다. 





뷰가 화면을 그리는 모든 책임을 가져간다

Vue코드의 상용 CDN은 코드의 최적화를 위해 띄어쓰기와 개행이 없다. 에러로 뱉지 않는다. 릴리즈 모드로 가면 브라우저 확장툴도 사용할 수 없다.



### 객체 지향 5대 원칙

1. 단일 책임원칙, 책임이란 기능 정도로 해석하면 된다.
2. 







## 뷰 라우터



유저 컴포넌트 위에 아무것도 없으면

파라미터가 아무것도 바라보지 않는다.



### 네임드 뷰

이름을 주는 컴포넌트에서 이름을 찾는다.



axios 는 자바스크립트 라이브러리 

초기에는 Vue 리소스를 썼었지만 2016년 말에 에반이 공식적으로 지원 종료..!

데이터 통신은 보통 비동기 처리를 한다.

너가 처리를 다했으면 이 함수를 실행시켜줘..!

언제 올지 모르므로..! 데이터가 안 올경우..! 





### Axios

갑자기 에러가 발생했을 때 catch가 발생한다.



## 뷰

### v-once

데이터가 10번 변하면..! 한 번 바꾸겠다..와 같은 명령을 코드로 작성할 수도 있다?! 

화면을 그리는 작업은 연산 비용이 비싸므로 데이터가 바뀔 때마다 화면을 다시 그리면 연산비용이 많이 들 수 있다. 그래서 10번 바뀔 때 한 번 바꾸거나 다양한 방법을 사용한다. 그러면 문제가 터질 수 있으므로..! 우리가 필요한 시점에 업데이트를 친다.!

쓰는 방법은 그때그때 다르지만..! 

>  특정 화면에서 업데이트가 너무 잦으니 업데이트 시점의 주체를 가져와서 해결한 적이 있다는 어느 개발자의 이야기.





### 표현식

표현식을 통해 연산이 가능하다. 화면단에는 로직을 처리하지 말고, computed를 사용하자

### 개발자님은 제이쿼리가 뷰보다 어렵다고 생각하신다.. 

제이쿼리가 분명히 어려운 게 있으니까 뷰 같은 프레임워크가 웹의 생산성을 높이기 위해서 등장한 것이다.

제이쿼리는 강력하지만 `DOM`을 찾아 들어가는 과정이 어렵고 성능을 개선하기 어렵다..! 

첨언을 하자면 해외에서는 최소한의 데이터만 왔다갔다하려고 네이티브 앱으로 가는 추세이다.

뷰에서 `v-for` 문을 쓸 때는 꼭 ` v-bind:key`속성을 사용해야 한다. 그렇지 않으면 뷰를 사용하는 목적과 이유가 사라진다. 키가 없다고 에러나지는 않지만..! 키를 넣어주어야 뷰의 알고리즘에 따라서 최적화를 할 수 있다.

> 그리고 쓰긴 쓰 데 왠만하면 유니크하게 써라. 변경된 부분만 빠르게 찾으려면 키가 있는 부분만 찾으면 된다.

이 리스트에서 뭐가 바뀌는 줄 모른다. 



### 디렉티브 속성의 사용처

### v-

`if`는 로그인을 처리할 때 주로 사용하게 된다.

`for`는 게시물을 만들 때 주로 사용한다. `for`문에는 `key`값이 들어간다.

`v-show` 와  `v-if` 의 차이는 메모리에 올라갈 떄 차이가 생긴다.! 미리 화면을 그려놓으면 연산비용을 아낄 수 있으므로..! 프로그램의 규모나 상황에 따라서 선택해서 써야 하는 상황이 생길 수 있다. 

`v-on`: @로 바꿔서 사용할 수 있다.

`v-model`은 변경되었을 때, 속성을 연동해놓으면...! 바로바로 연동이 된다. 같은 작업을 리액트에서 처리할 때는 더 복잡해진다..! 



## 고급 템플릿 문법 

### 백엔드보다 프론트가 더 민감하다

1초나 2초 보다 화면이 늦게 뜨면..! 사용자들은 화면을 닫는다.

굉장히 속도에 민감한...! 화면이 있다면..! 자바스크립트 표현식의 사용을 자제해야 한다.

가급적이면 모든 표현식은 `computed`속성 안에 넣는 게 좋다. 



### 캐싱

데이터에 접근하는 시간이 오래 걸릴 때 미리 저장해둠

캐싱을 무한대로 걸면 데이터가 바로바로 반영이 안되므로 텀을 주는 경우가 있다. 

캐싱은 실제로 많이 쓰게 된다. 

씨피유 내부에 캐시 메모리가 있다. 씨피유나 메모리 구조 쪽을 보면..!  

메모리가 비싼 연산을 위해서는 캐싱을 이용하는 게 좋다. 



캐싱을 위해선 캐싱 전략을 다 세워야 한다.

데이터가 변경되기 전까지는 한 번 연산을 한다. 뷰를 쓰게 되면 프레임워크가 최적화된 전략을 써준다..! 기본적인 성능은 보장을 해주려고 한다. 



> 개발을 진행하다 막히는 경우, 만들고 싶은 기능이 있다면 구현 전에 미리 찾아보는 것도..! 좋다. 어쩌면 이미 만들어져 있을 수도 있다

### 비동기

실제 네트워크로 가지고 온 다음 데이터가 변경 안 되는 상황이 생길 때 왓치에 태워서 바로 바꾸어 버릴 수가 있다. 

### 원웨이와 투웨이 방식의 차이

뷰는 상태가 바뀌면 바로 변경되는 방식이며, 리액트는 데이터를 가지고 와서 서버로 쳐야 한다..!!

뷰는 데이터가 변경되면 갱신하는 방식이므로, 서버로 데이터를 보내는 같은 작업을 하더라도 리액트에 비해 코드의 양이 줄어든다. 

### 웹 팩

웹팩을 통해서 css와 js파일을 압축해서 만들어 준다. 웹팩을 잘 쓰게 되면 할 수 있는 게 너무나 많다.



### 프록시

특정 에이피아이를 통해서 서버들의 경로들을 분할할 수 있는 정말 많은 기능들이 있다. 

### TDD 

TDD가 지금은 확 죽어버렸다...!

테스팅에 어떤 문제가 있다고 얘기했는데 반박을 못함

테스트를하게 되면 다 에러가 남..! 개발자가 리팩토링을 맘놓고, 믿으며 할 수 있었다.

테스팅을 자동화할 수 있다는 장점이 있었지만 

테스팅 화면이 잘못되면 있으나 마나 아니냐...! 테스팅 자체가 문제가 되면 ..! 쓸모가 없다... 라는 질문에 반박할 수가 없었다.. TDD의 창시자는



### 포트를 여러개 띄울 수 있는 방법은 알아두는 것이 좋다. 

```javascript
devServer: {
  historyApiFallback: true,
  port: 8081, // port번호를 설정할 수 있다.
  noInfo: true,
  overlay: true
},
```



### 웹 팩은 자바스크립트 파일만 인식한다

뷰 로더가 없으면 인식을 못한다. 뷰로더가 그 역할을 한다.

뷰로더는 웹팩이랑 자바스크립트 사이에 위치한다. 중간의 매개 역할을 한다.



## 프론트는 UI 요구사항이 많고, 백엔드는 데이터 정리와 같은 요구사항이 많다.

예전에는 폴더와 파일을 잘 나눠놓아야 했지만..! 지금은 에디터들이 좋아서! 기본적으로 검색으로 찾는 개발자들도 있다.

### 그림자 속성과 투명도 연산은 비용이 비싸다...!

로직상 문제가 없으면 디자인쪽 문제가 있을 것이다..! 그림자랑 투명도 연산에 대해서는 주의해야 한다. 개발자들은 그림자 연산을 싫어함.. 화면을 그리는 비용이 높음



### debugger

디버거는 잘 사용해야만 한다. 



### 앞 뒤 공백 제거...!

.trim()



인풋박스의 입력값을 초기화 하는 것도 중요하다.



### 네트워크를 타는 건 created를 사용한다.



### key 속성, 브라우저가 로딩되는 과정을 위해서 중요하다

예전에 개수 만개까지 뿌려주는 라이브러리가 있었는데, 웹 브라우저의 성능이 좋지 않았던 시대에는 각광을 받았다. 그렇지만 요즘은 뷰를 쓰면 한 방에 끝나버린다. 



### 뷰가 쉽다는 이유는 데이터만 가지고 놀면 된다.

뷰가 쉽다고 이야기되는 이유는 데이터만 가지고 놀면 되기 때문이다. 리액트는 데이터를 변경하고 상태를 호출해야 하므로 뷰에 비해서 더 많은 과정이 요구된다. 



### 투 웨이와 원웨이 방식의 차이

v-model의 데이터 바인딩을 통해서 양방향 데이터 바인딩이 이루어지고

데이터 바인딩은 양방향 데이터 바인딩을 한다.

컴포넌트 간에 통신은 양방향으로 한다. 





## 웹 팩 test

```bash
vue init webpack


```

config 폴더가 생김





### 프로젝트

프론트나 백을 전반적으로 아울러 보는 게 좋다. 





